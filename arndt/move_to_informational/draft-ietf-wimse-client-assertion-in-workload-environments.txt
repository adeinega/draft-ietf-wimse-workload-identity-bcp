



WIMSE                                                         B. Hofmann
Internet-Draft                                             H. Tschofenig
Intended status: Informational                                   Siemens
Expires: 20 April 2025                                       E. Giordano
                                                                   Nokia
                                                            Y. Rosomakho
                                                                 Zscaler
                                                      A. Schwenkschuster
                                                               Microsoft
                                                         17 October 2024


          OAuth 2.0 Client Assertion in Workload Environments
   draft-ietf-wimse-client-assertion-in-workload-environments-latest

Abstract

   The use of the OAuth 2.0 framework for container orchestration
   systems poses a challenge as managing secrets, such as client_id and
   client_secret, can be complex and error-prone.  Instead of manual
   provisioning these credentials the industry has moved to a
   federation-based approach where credentials of the underlying
   workload platform are used as assertions towards an OAuth
   authorization server leveraging the Client Assertion Flow [RFC7521],
   in particular [RFC7523].

   This approach is seen in the industry across many workload
   environments, this document outlines common patterns and their use
   cases.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 April 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Patterns
     3.1.  Kubernetes
     3.2.  Secure Production Identity Framework For Everyone (SPIFFE)
     3.3.  Cloud Providers
     3.4.  Continues integration/deployment systems
   4.  Security Considerations
   5.  IANA Considerations
   6.  Acknowledgements
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Authors' Addresses

1.  Introduction

   Workloads often require access to external resources to perform their
   tasks.  For example, access to a database, a web server or another
   workload.  These resources are protected by an authorization server
   and can only be accessed with an access token.  The challenge for
   workloads is to get this access token issued.

   Traditionally, workloads can be provisioned with client secrets
   credentials and use the client_credential flow to retrieve an access
   token.  This model comes with a set of challenges that make it
   insecure and high-maintaince.  Client secrets need to be manually
   provisioned and rotated.  They can be stolen and used by attackers to
   impersonate the workload.

   A solution to this problem is to not provision secret material to the
   workload itself but use the workload platform to attest for that
   workload.  Many workload platforms offer a credential, in most cases
   a JWT token.  Signed by a platform-internal authorization server,
   this credential attests the workload and its attributes.  Based on
   [RFC7521] and its JWT profile [RFC7523], this credential can then be
   used as a client assertion towards a different authorization server.
   Figure 1 illustrates this interaction.

   ┌──────────────────────────────────────────────────────────┐
   │                           External Authorization Domain  │
   │                                                          │
   │ ┌─────────────────────────┐     ┌────────────────────┐   │
   │ │                         │     │                    │   │
   │ │   Authorization Server  │     │  Resource Server   │   │
   │ │                         │     │                    │   │
   │ └────────────┬────────────┘     └────────────▲───────┘   │
   │              │                               │           │
   └──────────────┼───────────────────────────────┼───────────┘
                  │                               │
        2) present assertion                 3) access
                  │                               │
                  │     ┌─────────────────────────┘
                  │     │
   ┌──────────────┼─────┼─────────────────────────────────────┐
   │              │     │                  Workload Platform  │
   │              │     │                                     │
   │  ┌───────────┴─────┴───┐           ┌──────────────────┐  │
   │  │                     │           │ Credential       │  │
   │  │  Workload           ├───────────► issued by        │  │
   │  │                     │  1) get   │ Platform         │  │
   │  └─────────────────────┘           └──────────────────┘  │
   │                                                          │
   │                                                          │
   └──────────────────────────────────────────────────────────┘

      Figure 1: OAuth2 Assertion Flow in generic Workload Environment

   The figure outlines the following steps which are applicable in any
   pattern.

   *  1) retrieve credential issued by platform.  The way this is
      acchieved and whether this is workload or platform initiated
      differs based on the platform.

   *  2) present credential as an assertion towards an authorization
      server in an external authorization domain.  This step uses the
      assertion_grant flow defined in [RFC7521] and, in case of JWT
      format, [RFC7523].  As a result of this flow, an access token is
      returned to the workload.

   *  3) use access token from the previous step to access a protected
      resource in the external authorization domain.

   This specifiation defines this flow in more detail based on common
   pattern seen in the industry and gives reccomendations.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The terms 'workload' and 'container' are used interchangeably.

3.  Patterns

3.1.  Kubernetes

   Kubernetes notion of identity is mainly the concept of "service
   accounts" which are either created explictly or automatically during
   deployment time.  While the mean purpose of these identities is to
   authenticate access to the Kubernetes Control Plane it is more and
   more used to authenticate workloads between each other too.  The
   credential format used to authenticate service account is JWT that
   are signed by the Kubernetes Control Plane.

   To programatically use service account tokens workloads can

   *  use the TokenRequest API of the control plane

   *  have the token projected into the file system of the workload.
      This is commonly referred to as "projected service accout token".

   Both options allow workloads to

   *  specify a custom audience.  Possible audiences can be restricted
      based on control plane policy.

   *  specify a custom lifetime.  (TODO, is policy possible?)

   *  bind the token lifetime to an object lifecycle.  This allows the
      token to be invalidated when the object is deleted.  For example,
      when a Kubernetes Deployment is removed from the server.  It is
      important to highlight, that invalidation is only in effect if the
      TokenReview API of Kubernetes is used to validate the token.

   To validate service account tokens, Kubernetes offers workloads to

   *  mount the public keys used to sign the tokens into the file system
      of the workload.  This allows workloads to decentrally validate
      the tokens signature.

   *  make us of the TokenReview API.  This API introspects the token,
      makes sure it hasn't been invalidated and returns the claims.

   *  Optionally, a JSON Web Key Set is exposed via a webserver.  This
      allows the Service Account Token to be validated outside of the
      cluster and without line of sight towards the actual Kubernetes
      Control Plane API.

   ┌───────────────────────────────────────────────────────┐
   │                                  Authorization Domain │
   │                                                       │
   │ ┌──────────────────────────┐ ┌────────────────────┐   │
   │ │                          │ │                    │   │
   │ │   Authorization Server   │ │  Resource Server   │   │
   │ │                          │ │                    │   │
   │ └────────────▲─────────────┘ └──────────▲─────────┘   │
   │              │                          │             │
   └──────────────┼──────────────────────────┼─────────────┘
                  │                          │
         3) present assertion            4) access
                  │                          │
   ┌──────────────┼──────────────────────────┼─────────────┐
   │              │             ┌────────────┘  Kubernetes │
   │              │             │                  Cluster │
   │    ┌─────────┴─────────────┴────┐                     │
   │    │                            │                     │
   │    │    Workload                │                     │
   │    │                            │                     │
   │    └────▲────────────────▲──────┘                     │
   │         │                │                            │
   │         │                │                            │
   │    1) schedule     2) project service                 │
   │         │             account token                   │
   │         │                │                            │
   │   ┌─────┴────────────────┴───────────────────┐        │
   │   │                                          │        │
   │   │        Kubernetes Control Plane          │        │
   │   │                                          │        │
   │   └──────────────────────────────────────────┘        │
   │                                                       │
   └───────────────────────────────────────────────────────┘

    Figure 2: OAuth2 Assertion Flow in a Kubernetes Workload Environment

   The steps shown in Figure 2 are:

   *  1) The Kubernetes Control Plane schedules the workload.  This is
      much simplified and technically happens asynchronously.

   *  2) The Kubernetes Control Plane projects the service account token
      into the workload.  This step is also much simplified and
      technically happens alongside the scheduling with step 1.

   *  3) Workloads present the project service account token as a client
      assertion towards an external authorization server according to
      [RFC7523].  An access token is returned to the workload as a
      result.

   *  4) The access token issued by the external authorization server is
      used by the workload to access the projected resource.

   As an example, the following JSON showcases the claims a Kubernetes
   Service Account token carries.

   {
     "aud": [  # matches the requested audiences, or the API server's default audiences when none are explicitly requested
       "https://kubernetes.default.svc"
     ],
     "exp": 1731613413,
     "iat": 1700077413,
     "iss": "https://kubernetes.default.svc",  # matches the first value passed to the --service-account-issuer flag
     "jti": "ea28ed49-2e11-4280-9ec5-bc3d1d84661a",  # ServiceAccountTokenJTI feature must be enabled for the claim to be present
     "kubernetes.io": {
       "namespace": "kube-system",
       "node": {  # ServiceAccountTokenPodNodeInfo feature must be enabled for the API server to add this node reference claim
         "name": "127.0.0.1",
         "uid": "58456cb0-dd00-45ed-b797-5578fdceaced"
       },
       "pod": {
         "name": "coredns-69cbfb9798-jv9gn",
         "uid": "778a530c-b3f4-47c0-9cd5-ab018fb64f33"
       },
       "serviceaccount": {
         "name": "coredns",
         "uid": "a087d5a0-e1dd-43ec-93ac-f13d89cd13af"
       },
       "warnafter": 1700081020
     },
     "nbf": 1700077413,
     "sub": "system:serviceaccount:kube-system:coredns"
   }

         Figure 3: Example Kubernetes Service Account Token claims

3.2.  Secure Production Identity Framework For Everyone (SPIFFE)

   Secure Production Identity Framework For Everyone, also known as
   SPIFFE, is a cloud native compute foundation (CNCF) adopted project
   which defines an API definitioned called "Workload API" to delivery
   machine identity to workloads.  Workloads can retrieve either X509
   based or JWT credentials without the need to authenticate making it
   very easy to use.  How workloads authenticate on the API is not part
   of the specification.  It is common to use platform metadata from the
   operating system and the workload platform for authentication on the
   Workload API.

   For the scope of this document, the JWT formatted credential is the
   most relevant one.  SPIFFE referres to it as "JWT-SVID" (JWT - Single
   Verifyable Identity Document).

   Workloads are required to specify at least one audience when
   requesting a JWT-SVID from the Workload API.

   To allow validation, SPIFFE offers

   *  to download a set JWK encoded public keys that can be used to
      validate JWT signatures.  In SPIFFE this is referred to as the
      "JWT trust bundle".

   *  invoke a validation method on the Workload API to validate JWT-
      SVIDs

   Additionally, many SPIFFE deployments choose to separately publish
   the signing keys as a JSON Web Key Set on a web server to allow
   validation where the Workload API is not available.

   The following figure illustrates how a workload can use its JWT-SVID
   to access a protected resource outside of SPIFFE.

   ┌───────────────────────┐   ┌──────────────────────┐
   │                       │   │                      │
   │ Authorization Server  │   │  Protected Resource  │
   │                       │   │                      │
   └──────────▲────────────┘   └───────────▲──────────┘
              │                            │
     2) present assertion              3) access
              │                            │
   ┌──────────┴────────────────────────────┴──────────┐
   │                                                  │
   │                     Workload                     │
   │                                                  │
   └────────────────────────┬─────────────────────────┘
                            │
                     1) get JWT-SVID
                            │
   ┌────────────────────────▼─────────────────────────┐
   │                                                  │
   │                SPIFFE Workload API               │
   │                                                  │
   └──────────────────────────────────────────────────┘

          Figure 4: OAuth2 Assertion Flow in a SPIFFE Environment

   The steps shown in Figure 4 are:

   *  1) The workload retrieves JWT-SVID from the SPIFFE Workload API.

   *  2) The workload presents the JWT-SVID as a client assertion in the
      assertion flow based on [RFC7523].  An access token is returned to
      the workload.

   *  3) The access token returned in the previous step is used by the
      workload to access a protected resource.

   The claims of a JWT-SVID for example looks like this.

   {
     "aud": [
       "my-audience"
     ],
     "exp": 1729087175,
     "iat": 1729086875,
     "sub": "spiffe://example.org/myservice"
   }

3.3.  Cloud Providers

   Workload in cloud platforms can have any shape or form.
   Historically, virtual machines were the most common, with the
   introduction of containerization, hosted container environment or
   Kubernetes clusters were introduced, and lately, serverless functions
   are offered.  Regardless of the actual workload packaging,
   distribution and runtime platform, all are in need of identity.

   To create a common identity interface across cloud services and
   offerings, the pattern of an Instance Metadata Endpoint has been
   established by the biggest cloud providers.  Next to the option for
   workloads to get metadata about themselves, it also allows them to
   receive identity.  The credential types offered can vary.  JWT,
   however, is the one that is common across all of them.  The issued
   credential allows proof to anyone it is being presented to, that the
   workload platform has attested the workload and it can be considered
   authenticated.

   Within a cloud provider the issued credential can often directly be
   used to access resources of any kind across the platform making
   integration between the services easy and credential less.  While the
   term is technically missleading, from a user perspective, no
   credential needs to be issued, provisioned, rotated or revoked, as
   everything is handled internally by the platform.

   Resources outside of the platform, for example resources or workloads
   in other clouds, generic web servers or on-premise resources, are
   most of the time, however, protected by different domains and
   authorization servers and deny the platform issued credential.  In
   this scenario, the pattern of using the platform issued credential as
   an assertion in the context of [RFC7521], for JWT particularly
   [RFC7523] towards the authorization server that protected the
   resource to get an access token.

   ┌───────────────────────────────────────────────────┐
   │                     External Authorization Domain │
   │                                                   │
   │ ┌──────────────────────┐  ┌─────────────────────┐ │
   │ │                      │  │                     │ │
   │ │ Authorization Server │  │ Protected Resource  │ │
   │ │                      │  │                     │ │
   │ └───────────▲──────────┘  └──────────▲──────────┘ │
   │             │                        │            │
   └─────────────┼────────────────────────┼────────────┘
                 │                        │
                 │                        │
       B1) present assertion          B2) access
                 │                        │
                 │    ┌───────────────────┘
   ┌─────────────┼────┼────────────────────────────────┐
   │             │    │                          Cloud │
   │             │    │                                │
   │   ┌─────────┴────┴───┐  1) get       ┌──────────┐ │
   │   │                  │     identity  │          │ │
   │   │  Workload        ├───────────────► Instance │ │
   │   │                  │               │          │ │
   │   └─────────┬────────┘               │ Metadata │ │
   │             │                        │          │ │
   │         A1) access                   │ Service/ │ │
   │             │                        │ Endpoint │ │
   │   ┌─────────▼────────────┐           │          │ │
   │   │                      │           └──────────┘ │
   │   │  Protected Resource  │                        │
   │   │                      │                        │
   │   └──────────────────────┘                        │
   └───────────────────────────────────────────────────┘

           Figure 5: OAuth2 Assertion Flow in a cloud environment

   The steps shown in Figure 5 are:

   *  1) The workload retrieves identity from the Instance Metadata
      Endpoint.

   In case the workload needs to access a resource within the cloud
   (protected by the same authorization server that issued the workload
   identity)

   *  A1) The workload directly access the protected resource with the
      credential issued in step 1.

   In case the workload needs to access a resource outside of the cloud
   (protected by a different authorization server).  This can also be
   the same cloud but different context (tenant, account).

   *  B1) The workload presents cloud-issued credential as an assertion
      towards the external authorization server using [RFC7523].  An
      access token is returned to the workload.

   *  B2) Using the access token from step B1, the workload is able to
      access the protected resource in the external authorization
      domain.

3.4.  Continues integration/deployment systems

   Continous integration and deployment systems allow their pipelines/
   workflows to receive identity every time they run.  Particularly in
   situations where build outputs need to be uploaded to resources
   protected by other authorization server, deployments need to be made,
   or more generally, protected resources to be accessed, [RFC7523] is
   used to federate the pipeline/workflow identity to an identity of the
   other authorization server.

   ┌──────────────────────────────────────────────────────────┐
   │                            External Authorization Domain │
   │                                                          │
   │ ┌──────────────────────────┐     ┌─────────────────────┐ │
   │ │                          │     │                     │ │
   │ │   Authorization Server   │     │  Protected Resource │ │
   │ │                          │     │                     │ │
   │ └───────────▲──────────────┘     └────────────▲────────┘ │
   │             │                                 │          │
   └─────────────┼─────────────────────────────────┼──────────┘
                 │                                 │
        3) present assertion                  4) access
                 │                                 │
   ┌─────────────┴─────────────────────────────────┴──────────┐
   │                    Task (Workload)                       │
   └────────▲───────────────────────────┬─────────────────────┘
            │                           │
      1) schedules                2) retrieve identity
            │                           │
   ┌────────┴───────────────────────────▼─────────────────────┐
   │                                                          │
   │       Continuous Integration / Deployment Platform       │
   │                                                          │
   └──────────────────────────────────────────────────────────┘

   Figure 6: OAuth2 Assertion Flow in a continous integration/deployment
                                environment

   The steps shown in Figure 6 are:

   *  1) The continuous integration / deployment platform (CI-CD
      platform) schedules a task (considered a workload) to be
      performed.

   *  2) The workload is able to retrieve identity from the CI-CD
      platform.  This can differ based on the platform and potentially
      is already supplied during scheduling phase in step 1.

   *  3) The workload presents the CI-CD issued credential as an
      assertion towards the authorization server in the external
      authorization domain based on [RFC7521].  In case of JWT also
      [RFC7523].  The authorization server returns an access token to
      the workload.

   *  4) Using the access token from step 3, the workload is able to
      access the protected resource in the external authorization
      domain.

   Tokens of different providers look different, but all of them contain
   claims carrying the basic context of the executed tasks such as
   source code management data (e.g. git branch), initiation and more.

4.  Security Considerations

   This entire document is about security.

5.  IANA Considerations

   This document does not require actions by IANA.

6.  Acknowledgements

   Add your name here.

7.  References

7.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6749>.

   [RFC7521]  Campbell, B., Mortimore, C., Jones, M., and Y. Goland,
              "Assertion Framework for OAuth 2.0 Client Authentication
              and Authorization Grants", RFC 7521, DOI 10.17487/RFC7521,
              May 2015, <https://www.rfc-editor.org/rfc/rfc7521>.

   [RFC7523]  Jones, M., Campbell, B., and C. Mortimore, "JSON Web Token
              (JWT) Profile for OAuth 2.0 Client Authentication and
              Authorization Grants", RFC 7523, DOI 10.17487/RFC7523, May
              2015, <https://www.rfc-editor.org/rfc/rfc7523>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8414]  Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0
              Authorization Server Metadata", RFC 8414,
              DOI 10.17487/RFC8414, June 2018,
              <https://www.rfc-editor.org/rfc/rfc8414>.

7.2.  Informative References

   [OIDC]     Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and
              C. Mortimore, "OpenID Connect Core 1.0 incorporating
              errata set 1", November 2014,
              <https://openid.net/specs/openid-connect-core-1_0.html>.

Authors' Addresses

   Benedikt Hofmann
   Siemens
   Email: hofmann.benedikt@siemens.com


   Hannes Tschofenig
   Siemens
   Email: hannes.tschofenig@gmx.net


   Edoardo Giordano
   Nokia
   Email: edoardo.giordano@nokia.com


   Yaroslav Rosomakho
   Zscaler
   Email: yrosomakho@zscaler.com


   Arndt Schwenkschuster
   Microsoft
   Email: arndts.ietf@gmail.com
